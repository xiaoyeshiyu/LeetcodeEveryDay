//一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
//
//
//'A' -> "1"
//'B' -> "2"
//...
//'Z' -> "26"
//
// 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：
//
//
// "AAJF" ，将消息分组为 (1 1 10 6)
// "KJF" ，将消息分组为 (11 10 6)
//
//
// 注意，消息不能分组为 (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。
//
// 给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
//
// 题目数据保证答案肯定是一个 32 位 的整数。
//
//
//
// 示例 1：
//
//
//输入：s = "12"
//输出：2
//解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
//
//
// 示例 2：
//
//
//输入：s = "226"
//输出：3
//解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
//
//
// 示例 3：
//
//
//输入：s = "06"
//输出：0
//解释："06" 无法映射到 "F" ，因为存在前导零（"6" 和 "06" 并不等价）。
//
//
//
//
// 提示：
//
//
// 1 <= s.length <= 100
// s 只包含数字，并且可能包含前导零。
//
//
// Related Topics 字符串 动态规划 👍 1317 👎 0

package main

//leetcode submit region begin(Prohibit modification and deletion)
func numDecodings(s string) int {
	if s[0] == '0' {
		return 0
	}
	all := make(map[string]bool)
	for i := 0; i < 26; i++ {
		all[strconv.Itoa(i+1)] = true
	}

	// dp定义，是加上一个字符的时候，代表的解码总数
	dp := make([]int, len(s)+1)
	// 初始化条件，注意，默认0位置是1，代表一个字符都没有，也是1种，用于后续给两个字符的时候相叠加，只有1个字符也是1，排除了0为首的情况
	dp[0], dp[1] = 1, 1

	for i := 1; i < len(s); i++ {
		// 状态转移方程，如果当前字符合法，则数目为加上f(n-1)
		if all[string(s[i])] {
			dp[i+1] += dp[i]
		}
		// 如果与前一个字符一起合法，则数目为加上f(n-2)
		if all[s[i-1:i+1]] {
			dp[i+1] += dp[i-1]
		}
	}
	// 结果为dp的最后一个数
	return dp[len(s)]
}

//leetcode submit region end(Prohibit modification and deletion)
