## 动态规划

整理一下题意，对于字符串 `p` 而言，有三种字符：

* 普通字符：需要和 `s` 中同一位置的字符完全匹配
* `'.'`：能够匹配 `s` 中同一位置的任意字符
* `'*'`：不能够单独使用 `'*'`，必须和前一个字符同时搭配使用，数据保证了 `'*'` 能够找到前面一个字符。能够匹配 `s` 中同一位置字符任意次。

所以本题关键是分析当出现 `a*` 这种字符时，是匹配 0 个 a、还是 1 个 a、还是 2 个 a ...

本题可以使用动态规划进行求解：

* 状态定义：`f(i,j)` 代表考虑 `s` 中以 `i` 为结尾的子串和 `p` 中的 `j` 为结尾的子串是否匹配。即最终我们要求的结果为 `f[n][m]` 。

* 状态转移：也就是我们要考虑 `f(i,j)` 如何求得，前面说到了 `p` 有三种字符，所以这里的状态转移也要分三种情况讨论：
  1. `p[j]` 为普通字符：匹配的条件是前面的字符匹配，同时 `s` 中的第 `i` 个字符和 `p` 中的第 `j` 位相同。 即 `f(i,j) = f(i - 1, j - 1) && s[i] == p[j]` 。
  2. `p[j]` 为 `'.'`：匹配的条件是前面的字符匹配， `s` 中的第 `i` 个字符可以是任意字符。即 `f(i,j) = f(i - 1, j - 1) && p[j] == '.'`。
  3. `p[j]` 为 `'*'`：读得 `p[j - 1]` 的字符，例如为字符 a。 然后根据 `a*` 实际匹配 `s` 中 `a` 的个数是 0 个、1 个、2 个 ...
     3.1. 当匹配为 0 个：`f(i,j) = f(i, j - 2)`
     3.2. 当匹配为 1 个：`f(i,j) = f(i - 1, j - 2) && (s[i] == p[j - 1] || p[j - 1] == '.')`
     3.3. 当匹配为 2 个：`f(i,j) = f(i - 2, j - 2) && ((s[i] == p[j - 1] && s[i - 1] == p[j - 1]) || p[j - 1] == '.')`
     ...

**我们知道，通过「枚举」来确定 `*` 到底匹配多少个 `a` 这样的做法，算法复杂度是很高的。**

**我们需要挖掘一些「性质」来简化这个过程。**

![640.png](https://pic.leetcode-cn.com/1611397993-lmpHIZ-640.png)

代码：

* []

```Java
class Solution {
    public boolean isMatch(String ss, String pp) {
        // 技巧：往原字符头部插入空格，这样得到 char 数组是从 1 开始，而且可以使得 f[0][0] = true，可以将 true 这个结果滚动下去
        int n = ss.length(), m = pp.length();
        ss = " " + ss;
        pp = " " + pp;
        char[] s = ss.toCharArray(), p = pp.toCharArray();
        // f(i,j) 代表考虑 s 中的 1~i 字符和 p 中的 1~j 字符 是否匹配
        boolean[][] f = new boolean[n + 1][m + 1];
        f[0][0] = true;
        for (int i = 0; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                // 如果下一个字符是 '*'，则代表当前字符不能被单独使用，跳过
                if (j + 1 <= m && p[j + 1] == '*') continue;
                
                if (i - 1 >= 0 && p[j] != '*') {
                    // 对应了 p[j] 为普通字符和 '.' 的两种情况
                    f[i][j] = f[i - 1][j - 1] && (s[i] == p[j] || p[j] == '.');
                } else if (p[j] == '*') {
                    // 对应了 p[j] 为 '*' 的情况
                    f[i][j] = (j - 2 >= 0 && f[i][j - 2]) || (i - 1 >= 0 && f[i - 1][j] && (s[i] == p[j - 1] || p[j - 1] == '.'));
                }
            }
        }
        return f[n][m];
    }
}
```

* 时间复杂度：n 表示 s 的长度，m 表示 p 的长度，总共 $n * m$ 个状态。复杂度为 $O(n * m)$
* 空间复杂度：使用了二维数组记录结果。复杂度为 $O(n * m)$

---

## 最后

**如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ ("▔□▔)/**

**如有不理解的地方，欢迎你在评论区给我留言，我都会逐一回复 ~**

也欢迎你 [关注我](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png) 和 加入我们的[「组队打卡」](https://leetcode-cn.com/u/ac_oier/)小群 ，提供写「证明」&「思路」的高质量题解
